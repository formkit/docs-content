---
title: Custom Inputs
description: Create your own inputs that automatically inherit FormKit’s value-added features such as validation, error messages, data modeling, grouping, labels, help text and more.
---

# Custom inputs

::Cta
---
label: "Building your first custom input?" 
type: "ghost" 
href: "/guides/create-a-custom-input" 
button: "Read the guide"
---
::

FormKit includes many inputs out of the box, but you can also define your own inputs that automatically inherit FormKit’s value-added features like validation, error messages, data modeling, grouping, labels, help text and others.

::Callout
---
type: "info"
label: "Modify or restructure an existing input"
---
If your use case requires modifications of an existing input, such as moving sections, changing or restructuring HTML elements, etc., consider using FormKit's <a href="/guides/export-and-restructure-inputs">input export feature</a>.
::

Inputs are comprised of two essential parts:

1. [An input definition](#input-definition).
2. The input’s code: [a schema](#schema-inputs) or a [component](#component-inputs).

::Callout
---
type: "warning"
label: "Start with the guide"
---
If you are just getting started with custom inputs, consider reading the “<a href="/guides/create-a-custom-input">Create a custom input</a>” guide. The content on this page is intended to explain the intricacies of custom inputs for advanced use cases like authoring a plugin or library and is not required for many common use cases.
::

## Registering inputs

New inputs require an [input definition](#input-definition). Input definitions can be registered with FormKit three ways:

- Locally on a `FormKit` component [with the `type` prop](#using-the-type-prop).
- [Globally using defaultConfig](#global-custom-inputs).
- [Selectively using plugin libraries](#plugin-libraries).

### Input definition

Input definitions are objects that contain the necessary information to initialize an input — like which [props to accept](#adding-props), what [schema or component to render](#schema-vs-component), and if any additional [feature functions](#adding-features) should be included. The shape of the definition object is:

```js
{
  // Node type: input, group, or list.
  type: 'input',
  // Schema to render (schema object or function that returns an object)
  schema: [],
  // A Vue component to render (use schema _OR_ component, but not both)
  component: YourComponent,
  // (optional) Input specific props the <FormKit> component should accept.
  // should be an array of camelCase strings
  props: ['fooBar'],
  // (optional) Array of functions that receive the node.
  features: []
}
```

### Using the `type` prop

Let’s make the simplest possible input — one that only outputs "Hello world".

::Example
---
name: "Custom input"
file: "_examples/custom-input/custom-input.vue"
---
::

Even though this simplistic example doesn’t contain any input/output mechanism, it still qualifies as a full input. It can have a value, run validation rules (they wont be displayed, but they can block form submissions), and execute plugins. Fundamentally, all inputs are [core nodes](/essentials/architecture#node) and the input’s definition provides the mechanisms to interact with that node.

### Global custom inputs

To use your custom input anywhere in your application via a "type" string (ex: `<FormKit type="foobar" />`) you can add an `inputs` property to the `defaultConfig` options. The property names of the `inputs` object become the "type" strings available to the `<FormKit>` component in your application.

```js
import { createApp } from 'vue'
import App from 'App.vue'
import { plugin, defaultConfig } from '@formkit/vue'

const helloWorld = {
  type: 'input',
  schema: ['Hello world'],
}

createApp(App)
  .use(
    plugin,
    defaultConfig({
      inputs: {
        // The property will be the “type” in <FormKit type="hello">
        hello: helloWorld,
      },
    })
  )
  .mount('#app')
```

Now that we’ve defined our input we can use it anywhere in the application:

::Example
---
name: "Custom input"
file: [
  '_examples/custom-input-default-config/custom-input-default-config.vue',
  '_examples/custom-input-default-config/formkit.config.js'
]
---
::

### Plugin libraries

The above example extends the `@formkit/inputs` library (via `defaultConfig`). However, a powerful feature of FormKit is its ability to [load input libraries from multiple plugins](/essentials/architecture#library). These inputs can then be registered anywhere plugins can be defined:

- Globally
- Per group
- Per form
- Per list
- Per input

Let’s refactor our hello world input to use its own plugin:

::Example
---
name: "Custom input - plugin"
file: "_examples/custom-input-plugin/custom-input-plugin.vue"
---
::

::Callout
---
type: "tip"
label: "Plugin inheritance"
---
Notice in the above example our plugin was defined on a parent of the element that actually used it! This is thanks to <a href="/essentials/architecture#plugins">plugin inheritance</a> — a core feature of FormKit plugins.
::

## Schema vs component

Your input can be written using [FormKit’s schema](/essentials/schema) or a generic Vue component. There are pros and cons to each approach:

<div class="reference-table">

| Code   | Pros                                                                                                                                                                                                                                                                                                                                          | Cons                                                                                                                                                                                                                                                                                                                           |
| ------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Vue    | <ul><li>Learning curve (you likely know how to write a Vue component).</li><li>More mature dev tooling.</li><li>Slightly faster initial render.</li></ul>                                                                                                                                                                                     | <ul><li>Cannot use the <a href="/essentials/inputs#sections-schema"><code>:sections-schema</code> prop</a> to modify structure.</li><li>Plugins cannot modify schema to change rendered output.</li><li>Framework specific (Vue only).</li><li>Easy to write inputs that don’t play well with the FormKit ecosystem.</li></ul> |
| Schema | <ul><li>Structure can be modified via the <code>:sections-schema</code> prop (if you allow it).</li><li>Plugins can modify/change the rendered output.</li><li>Framework agnostic (future portability to when FormKit supports new frameworks).</li><li>Ecosystem compatibility (great for publishing your own open source inputs).</li></ul> | <ul><li>Learning curve (need to <a href="/essentials/schema">understand schemas</a>).</li><li>Slightly slower initial render.</li><li>Less mature dev tooling.</li></ul>                                                                                                                                                       |

</div>

::Callout
---
type: "warning"
label: "Components in schemas"
---
Even if you prefer to write a custom input using a standard Vue Component, you can still use a schema in your input definition. Please read the <a href="#using-createinput-to-extend-the-base-schema">Using <code>createInput</code> to extend the base schema</a> section.
::

The primary takeaway is if you are planning to use a custom input on multiple projects — then consider using the schema-based approach. If your custom input will only be used on a single project and flexibility is not a concern, use a Vue component.

### Future proofing

In the future, FormKit may expand to support additional frameworks (ex: React or Svelte. If this is something you are interested in, <a href="mailto:feedback@formkit.com">let us know!</a>.) Writing your inputs using schema means your inputs will be compatible (perhaps minimal changes) with those frameworks too.

## Schema inputs

All of FormKit’s core inputs are written using schemas to allow for the greatest flexibility possible. You have two primary options when writing your own schema inputs:

- [Extend the base schema](#using-createinput-to-extend-the-base-schema) (recommended).
- Write your input from scratch.

It is important to understand the basic structure of a “standard” FormKit input, which is broken down into [sections](/essentials/inputs#sections):

<figure class="full">

  ::FormKitInputDiagram
  ---
  label-content: "Email address"
  prefix-content: ""
  suffix-content: ""
  input-content: "test@example.com"
  help-content: "Please use your school email address."
  message-content: "Please provide a valid email."
  ---
  ::

  <figcaption>Composition of a standard FormKit text input.</figcaption>
</figure>

The `input` section in the diagram above is typically what you’ll swap out when creating your own inputs — keeping the wrappers, labels, help text, and messages intact. However, if you want to control these aspects as well, you can also write your own input from scratch.

#### Using `createInput` to extend the base schema

To create inputs using the base schema you can use the `createInput()` utility from the `@formkit/vue` package. This function accepts 3 arguments:

- (required) A schema node _or_ a Vue component, which it inserts into the base schema at the `input` section (see diagram above).
- (optional) An object of [input definition](#input-definition) properties to merge with an auto-generated one.
- (optional) A sections-schema object (just [like the sections-schema prop](/essentials/inputs#sections-schema)) to merge with the base schema. This lets you modify the wrapping structure of the input.

The function returns a ready-to-use [input definition](#input-definition).

When providing a _component_ as the first argument, `createInput` will generate a schema object that references your component within the base schema. Your component will be passed a single `context` prop:

```js
{
  $cmp: 'YourComponent',
  props: {
    context: '$node.context'
  }
}
```

When providing a schema object, your schema is directly injected into the base schema object. Notice that our hello world example now supports outputting "standard" FormKit features like labels, help text, and validation:

::Example
---
name: "Create input"
file: "_examples/create-input/create-input.vue"
---
::

#### Writing schema inputs from scratch

It might make sense to write your inputs completely from scratch without using any of the base schema features. When doing so, just provide the [input definition](#input-definition) your full schema object.

::Example
---
name: "Create input"
file: "_examples/scratch-schema-input/scratch-schema-input.vue"
---
::

In the above example, we were able to re-create the same features as the `createInput` example — namely — label, help text, and validation message output. However, we are still missing a number of "standard" FormKit features like slot support. If you are attempting to publish your input or maintain API compatibility with the other FormKit inputs, take a look at the [input checklist](#input-checklist).

## Component inputs

::Callout
---
type: "info"
label: "Custom inputs vs Vue component wrappers"
---
When writing a custom FormKit input while using Vue components it is recommended to not use the FormKit components inside, custom inputs are meant to be written like regular inputs with the advantage of using the FormKit context prop to add the functionality that FormKit requires, if your case is to use a FormKit component with default values, it is recommended instead to use a Vue component wrapper and directly call that component, FormKit inputs work in any level of nesting, or you can also consider using FormKit's <a href="/guides/export-and-restructure-inputs">input export feature</a> to add features and change attrs and props.
::

For most users, [passing a Vue component to `createInput`](#using-createinput-to-extend-the-base-schema) provides a good balance between customization and value-added features. If you’d like to completely eject from schema-based inputs all together, you can pass a component directly to an input definition.

Component inputs receive a single prop — [the `context` object](/essentials/configuration). It’s then up to you to write a component to encompasses the desired features of FormKit (labels, help text, message display, etc.). Checkout the [input checklist](#input-checklist) for a list of what you’ll want to output.

## Input & output values

Inputs have two critical roles:

- Receiving user input.
- Displaying the current value.

### Receiving input

You can receive input from any user interaction and the input can set its value to any type of data. Inputs are _not_ limited to strings and numbers — they can happily store Arrays, Objects, or custom data structures.

Fundamentally, all an input needs to do is call `node.input(value)` with a value. The `node.input()` method is automatically debounced, so feel free to call it frequently — like every keystroke. Typically, this looks like binding to the `input` event.

The [`context` object](/essentials/configuration) includes an input handler for basic input types: `context.handlers.DOMInput`. This can be used for text-like inputs where the value of the input is available at `event.target.value`. If you need a more complex event handler, you can [expose it using "features"](#adding-features).

Any user interaction can be considered an input event. For many native HTML inputs, that interaction is captured with the [input event](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event).

```js
// An HTML text input written in schema:
{
  $el: 'input',
  attrs: {
    onInput: '$handlers.DOMInput'
  }
}
```

The equivalent in a Vue template:

```vue
<template>
  <input @input="context.DOMInput" />
</template>
```

### Displaying values

Inputs are also responsible for displaying the current value. Typically, you’ll want to use the `node._value` or `$_value` in schema to display a value. This is the "live" non-debounced value. The currently _committed_ value is `node.value` (`$value`). Read more about "value settlement" <a href="/essentials/architecture#setting-values">here</a>.

```js
// An HTML text input written in schema:
{
  $el: 'input',
  attrs: {
    onInput: '$handlers.DOMInput',
    value: '$_value'
  }
}
```

The equivalent in a Vue template:

```vue
<template>
  <input :value="context._value" @input="context.handlers.DOMInput" />
</template>
```

::Callout
---
type: "warning"
label: "_value vs value"
---
The only time the uncommitted input <code>_value</code> should be used is for displaying the value on the input itself — in all other locations, it is important to use the committed <code>value</code>.
::

## Adding props

The [standard FormKit props](/essentials/inputs#props--attributes) that you can pass to the `<FormKit>` component (like `label` or `type`) are available in the root of the [context object](/essentials/configuration) and in the [core node `props`](/essentials/architecture#config--props), and you can use these props in your schema by directly referencing them in expressions (ex: `$label`). Any props passed to a `<FormKit>` component that are not _node props_ end up in the `context.attrs` object (just `$attrs` in the schema).

If you need additional props, you can declare them in your input definition. Props can also be used to accept new props from the `<FormKit>` component but they are also used for internal input state (much like a `ref` in a Vue 3 component).

FormKit uses the `props` namespace for both purposes (see the autocomplete example below for an example of this). Props should _always_ be defined in camelCase and used in your Vue templates with kebab-case. There are 2 ways to define props:

1. [Array notation](#array-notation).
2. [Object notation](#object-notation).
3. [The node.addProps() method](#add-props-method)

### Array notation

::Example
---
name: "Custom props"
file: [
  "_examples/custom-props/custom-props.vue"
]
---
::

When extending the base schema by using the `createInput` helper, pass a second argument with input definition values to merge:

::Example
---
name: "Custom props - createInput"
file: [
  "_examples/custom-props-create-input/custom-props-create-input.vue"
]
---
::

### Object notation

Object notation gives you fine grained control over how your props are defined by giving you the ability to:

- Define a default value.
- Define `boolean` props that can be passed without a value.
- Define custom getter/setter functions.

::Example
---
name: "Custom props - object notation"
file: [
  "_examples/custom-props-create-input/custom-props-object-notation.vue"
]
---
::

### Add props method (`node.addProps()`)

You can dynamically add props using the `node.addProps()` method in any runtime environment where you have access to the node. For custom inputs this is particularly helpful when used in a features. Both array notation and object notation are supported (see above).

::Example
---
name: "Custom props - node.addProps"
file: [
  "_examples/custom-props-create-input/custom-props-add-props.vue"
]
---
::

## Adding features

Features are the preferred way to add functionality to a custom input type. A "feature" is a function that receives the [core node](/essentials/architecture#node) as an argument. Effectively, they are plugins without inheritance (so they only apply to the current node). You can use features to add input handlers, manipulate values, interact with props, listen to events, and much more.

Features are defined in an array to encourage code reuse when possible. For example, we [use a feature called “options”](https://github.com/formkit/formkit/blob/master/packages/inputs/src/features/options.ts) on `select`, `checkbox`, and `radio` inputs.

As an example, let's imagine you want to build an input that allows users to enter two numbers, and the value of the input is the sum of those two numbers:

::Example
---
  name: "Custom input - sum numbers"
  file: [
    "_examples/custom-sum/custom-sum.vue",
    "_examples/custom-sum/formkit.config.js"
  ]
---
::

## TypeScript support

FormKit is written in TypeScript and includes type definitions for all of its core inputs. If you are writing your own inputs and would like to provide TypeScript support you can define your own inputs using two module augmentations:

### Adding prop types

The `type` prop of the `<FormKit>` component is a string that is used as the key of a discriminated union of props (`FormKitInputProps`). By augmenting this type your custom inputs can define their own prop types. To do so you must augment the `FormKitInputProps` type to add your own custom types:

```ts
declare module '@formkit/inputs' {
  interface FormKitInputProps<Props extends FormKitInputs<Props>> {
    // This key and the `type` should match:
    'my-input': {
      // Define your input `type`:
      type: 'my-input',
      // Define an optional prop. Use camelCase for all prop names:
      myOptionalProp?: string | number
      // Define a required prop
      superImportantProp: number
      // Define the value type, this should always be a optional!
      value?: string | number
      // Use the Prop generic to infer information from another field, notice
      // we a utility "PropType" to infer the type of the `value` from the Props
      // generic:
      someOtherProp?: PropType<Props, 'value'>
    }
  }
}
```

### Adding slot types

If you define your own sections (slots) in your custom input, you can also add TypeScript support for those too. To do so, you must augment the `FormKitInputSlots` type to add your own custom slots:

```ts
declare module '@formkit/inputs' {
  interface FormKitInputProps<Props extends FormKitInputs<Props>> {
    'my-input' {
      type: 'my-input'
      // ... props here
    }
  }

  interface FormKitInputSlots<Props extends FormKitInputs<Props>> {
    'my-input': FormKitBaseSlots<Props>
  }
}
```

In the example above, we use `FormKitBaseSlots` — a TypeScript utility to add all the "basic" slots that most custom inputs implement, like `outer`, `label`, `help`, `message`, etc. However you could also define your own slots entirely from scratch, or augment `FormKitBaseSlots` to add additional slots (`FormKitBaseSlots<Props> & YourCustomSlots`).

```ts
declare module '@formkit/inputs' {
  // ... props here
  interface FormKitInputSlots<Props extends FormKitInputs<Props>> {
    'my-input': {
      // This will be the *only* slot available on the my-input input
      slotName: FormKitFrameworkContext & {
          // this will be available as slot data in the `slotName` slot
          fooBar: string
        }
      }
    }
  }
}
```

::Callout
---
type: "warning"
label: "Augment props first"
---
In order to augment the `FormKitInputSlots`, you must first have written an augmentation for `FormKitInputProps` that at least includes the `type` prop.
::



## Examples

Below are some examples of custom inputs. They are not intended to be comprehensive or production ready, but rather illustrate some custom input features.

### Simple text input

This is the simplest possible input and does not leverage any of FormKit’s built in DOM structure and only outputs a text input — however it is a fully functional member of the group it is nested inside of and able to read and write values.

::Example
---
  name: "Create input"
  file: "_examples/standard-text-input/standard-text-input.vue"
---
::

::Callout
---
type: "tip"
label: "DOM Input"
---
In the above example the <code>$handlers.DOMInput</code> is a built-in convenience function for <code>(event) => node.input(event.target.value)</code>.
::

### Autocomplete input

Let’s take a look at a slightly more complex example that utilizes `createInput` to provide all the standard FormKit structure while still providing a custom input interface.

::Example
---
name: "Create input"
file: [
  "_examples/autocomplete/autocomplete.vue",
  "_examples/autocomplete/autocompleteInput.js",
  "_examples/autocomplete/formkit.config.js"
]
initFileTab: 'autocompleteInput.js'
---
::

## Input checklist

FormKit exposes dozens of value-added features to even the most mundane inputs. When writing a custom input for a specific project, you only need to implement the features that will actually be used on that project. However, if you plan to distribute your inputs to others, you will want to ensure these features are available. For example, the standard `<FormKit type="text">` input uses the following schema for its `input` element:

```js
{
  $el: 'input',
  bind: '$attrs',
  attrs: {
    type: '$type',
    disabled: '$disabled',
    class: '$classes.input',
    name: '$node.name',
    onInput: '$handlers.DOMInput',
    onBlur: '$handlers.blur',
    value: '$_value',
    id: '$id',
  }
}
```

There are several features in the above schema that may not be immediately obvious like the `onBlur` handler. The following checklist is intended to help input authors cover all their bases:

<InputChecklist />
